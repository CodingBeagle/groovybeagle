import org.lwjgl.system.MemoryUtil.*

import org.lwjgl.glfw.*;
import org.lwjgl.glfw.GLFW.*
import org.lwjgl.opengl.*

import org.lwjgl.system.MemoryStack.*
import org.lwjgl.opengl.GL33.*
import org.lwjgl.opengl.GL43.*

var windowHandle: Long = 0

fun main() {
    init()
    loop()
    cleanup()
}

/*
    Functions in Kotlin are declared using the "fun" keyword.

    When a function does not return any useful value, its return type is "Unit". Unit is a type with only one value: Unit.
    A function whos return type is Unit will not have to declare it explicitly, it's simply implicit.

    The Unit object corresponds to "void" in languages like Java.
 */
fun init() {
    // Setup an error callback. The default implementation
    // will print the error message in System.err.
    GLFWErrorCallback.createPrint(System.err).set()

    // Initialize GLFW.
    // This has to be done before any other GLFW functions can be used.
    if ( !glfwInit() ) {
        throw RuntimeException("Failed to initialize GLFW!")
    }

    // Configure GLFW
    glfwDefaultWindowHints()

    // Make OpenGL Core Profile
    glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE)

    // Enable OpenGL Debug Context.
    // By enabling the OpenGL debug context, we can get more detailed error callbacks
    glfwWindowHint(GLFW_OPENGL_DEBUG_CONTEXT, GLFW_TRUE)

    // We want an OpenGL 3.3 context
    glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3)
    glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3)

    // The window will not be resizeable
    glfwWindowHint(GLFW_RESIZABLE, GLFW_FALSE)

    // The window will stay hidden after creation
    glfwWindowHint(GLFW_VISIBLE, GLFW_FALSE)

    // Create the window
    windowHandle = glfwCreateWindow(800, 600, "Groovy Beagle Engine!", 0, 0)
    if (windowHandle == 0L)
        throw RuntimeException("Failed to create window!")

    // Get the thread stack and push a new frame
    /*
        Kotlin has a generic extension on all "Closeable?" types.
        This type is used for Java's try-with-resources.
        This function takes a function literal block which gets executed in a try. Afterwards, the object will
        automatically be closed in a "finally".
     */
    val stack = stackPush();
    stack.use {
        val pWidth = stack.mallocInt(1) // int*
        val pHeight = stack.mallocInt(1) // int*

        // Get the window size passed to glfwCreateWindow
        glfwGetWindowSize(windowHandle, pWidth, pHeight)

        // Get the resolution of the primary monitor
        // Here we use the elvis operator ?:
        // It will evaluate the expression on the right side in the case that the left side is null.
        // We do this because the rest of the code in this block does not make sense if we fail to retrieve the
        // vidMode
        val vidMode = glfwGetVideoMode(glfwGetPrimaryMonitor()) ?: throw RuntimeException("Failed to retrieve video mode.");

        // Center the window
        glfwSetWindowPos(
            windowHandle,
            (vidMode.width() - pWidth.get(0)) / 2,
            (vidMode.height() - pHeight.get(0)) / 2
        )
    } // Stack frame is popped automatically at end of use

    // Make the OpenGL context current
    glfwMakeContextCurrent(windowHandle)

    // This line is critical for LWJGL's interoperation with GLFW's
    // OpenGL context, or any context that is managed externally.
    // LWJGL detects the context that is current in the current thread,
    // creates the GLCapabilities instance and makes the OpenGL
    // bindings available for use.
    GL.createCapabilities()

    println("**** OpenGL Context Information ****");
    println("${glGetString(GL_RENDERER)}, ${glGetString(GL_VERSION)}")
    println("************************************")

    // No debug messages will be generated byu the OpenGL context unless we enable it with this line
    // glEnable is used to enable various different server-side GL capabilities
    glEnable(GL_DEBUG_OUTPUT)

    // Register error callback function to the OpenGL context
    glDebugMessageCallback(GLDebugMessageCallbackI { source, type, id, severity, length, message, userParam ->

    }, 0)

    // Enable v-sync
    glfwSwapInterval(1)

    // Make the window visible
    glfwShowWindow(windowHandle)

    glBindBuffer(GL15.GL_ARRAY_BUFFER, 3)
}

fun loop() {
    // Set the clear color
    glClearColor(1.0f, 0.0f, 0.0f, 0.0f)

    while (!glfwWindowShouldClose(windowHandle)) {
        glClear(GL_COLOR_BUFFER_BIT or GL_DEPTH_BUFFER_BIT)

        glfwSwapBuffers(windowHandle);

        glfwPollEvents()
    }
}

fun cleanup() {
    println("Cleaning up...")

    // Clean up debug callback function
    GLDebugMessageCallback.create(glGetPointer(GL_DEBUG_CALLBACK_FUNCTION)).free();
}

