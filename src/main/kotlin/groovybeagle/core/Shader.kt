package groovybeagle.core

import org.lwjgl.opengl.GL43.*
import org.lwjgl.system.MemoryStack.stackPush

/*
    So far, any class I create representing a wrapper on top of a native resource follows a pattern of having a:
    - Create method
    - Delete method

    That the user of the class will have to manage manually. This means that the constructor will NOT be used for
    initialization.

    Reason: Wrappers around native resource APIs like OpenGL do not play well with the nondeterministic nature
    of garbage collectors in managed languages. Usually you only want to use native resources within a small limited
    scope, after which you want to dispose of them. Either that, or you want them in a longer lived scope, but actually
    make sure that their resources are released at the time of you not needing them any longer. Because of that
    you can't really (from what I can see) design a good RAII implementation in a managed language where
    you use the constructor for acquiring resources and a destructor for releasing them, because a managed language
    like Kotlin / Java doesn't have the concept of a stack vs heap, AND the "destructor" (finalize) is not really
    even guaranteed to be executed during the lifetime of your application. It will depend on what the garbage
    collector ends up doing. You're also not guaranteed any specific order of finalize methods being called.

    Therefore, in the case of native resources acquired through some native APIs, the best course of action seems
    to be to implement a manually controlled create / delete pattern.
 */
class Shader constructor(sourceCode: String, shaderType: Int) : NativeResource {
    var shaderObject: Int = 0
        get() {
            if (isDeleted)
                throw RuntimeException("Attempting to access deleted shader.")

            // The field keyword can be used to access the "backing field" of a property.
            // A backing field is an autogenerated field for any property, and the field
            // keyword can only be used inside the get / set accessor of the property.
            return field
        }

    private var isDeleted = false

    init {
        shaderObject = glCreateShader(shaderType)

        // In Java, a CharSequence is an interface. It represents a readable sequence of char values.
        // A String is one implementation using the CharSequence interface.
        glShaderSource(shaderObject, sourceCode)

        glCompileShader(shaderObject)

        // Get the thread stack and push a new frame
        val stack = stackPush()
        stack.use {
            val compilationSuccess = stack.mallocInt(1)

            glGetShaderiv(shaderObject, GL_COMPILE_STATUS, compilationSuccess)

            if (compilationSuccess.get(0) != GL_TRUE) {
                val compilationLog = glGetShaderInfoLog(shaderObject)

                throw RuntimeException("Failed to compile shader with the following error: $compilationLog")
            }
        }
    }

    override fun dispose() {
        if (isDeleted)
            throw RuntimeException("Attempting to delete shader already deleted.")

        glDeleteShader(shaderObject)

        shaderObject = 0
        isDeleted = true
    }
}